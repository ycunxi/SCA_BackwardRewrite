//
//  BenchGen-Comparator.cpp
//  Tools
//
//  Created by Cunxi Yu on 7/16/14.
//  Copyright (c) 2014 Cunxi Yu. All rights reserved.
//

#include "BenchGen-Comparator.h"
#include <iostream>
#include <fstream>
#include <unistd.h>
#include <sstream>
#include <string>
#include <stdio.h>
using namespace std;

void verilogFileComp()
{
    cout<<"/*This Verilog is generated by BechGen software.*/\n"
    "/*Designed by University of Massachusetts, Amherst, VLSI CAD LAB, Cunxi Yu*/\n"
    "/*/  Copyright (c) 2014 Cunxi Yu. All rights reserved. */ \n"
    "/*Contact: ycunxi@umass.edu */"<<endl;
}


void BenchGenComparator::comp(int x)
//The gate level Verilog HDL code for Addition(in1+in2)
{
    x--;
    string location(getcwd(NULL,0));
    string verilogdirectory="/verilogGenerated/";
    location+=verilogdirectory;
    stringstream outfilename;
    string filename="Comparator";
    int fileint=x+1;
    outfilename << filename << fileint << "Bits.v";
    string f=outfilename.str();
    string finaloutputfilename;
    finaloutputfilename=location+f;
    //cout<<finaloutputfilename;
    ofstream outfile(finaloutputfilename);
    outfile<<"/*This Verilog is generated by BechGen software.*/\n"
    "/*Designed by University of Massachusetts, Amherst, VLSI CAD LAB, Cunxi Yu*/\n"
    "/*/  Copyright (c) 2014 Cunxi Yu. All rights reserved. */ \n"
    "/*Contact: ycunxi@umass.edu */"<<endl;
    outfile<<"module subtractor"<<x+1<<"Bits(a,b,sel);"<<endl;
    outfile<<" input ["<<x<<":0] a,b;"<<endl;
    outfile<<" output sel;"<<endl;
    outfile<<" wire ["<<x<<":0] adder_add_cout;"<<endl;
    outfile<<"    assign initial_and = a[0] & !b[0] ;"<<endl;
    outfile<<"    assign initial_or = a[0] | !b[0]; "<<endl;
    outfile<<"    assign adder_add_cout[0] = initial_or | initial_and ;"<<endl;
    for (int i=1; i<=x+1; i++) {
        if (i!=x+1) {
            
            
            outfile<<"    assign adder_and"<<3*i-2<<" = adder_add_cout["<<i-1<<"] & a["<<i<<"];"<<endl;
            outfile<<"    assign adder_and"<<3*i-1<<" = adder_add_cout["<<i-1<<"] & !b["<<i<<"];"<<endl;
            outfile<<"    assign adder_and"<<3*i<<" = a["<<i<<"] & !b["<<i<<"];"<<endl;
            outfile<<"    assign adder_or"<<i<<" = adder_and"<<3*i-2<<" | "<<"adder_and"<<3*i-1<<";"<<endl;
            outfile<<"    assign adder_add_cout["<<i<<"] = adder_or"<<i<<" | ""adder_and"<<3*i<<";"<<endl;
            // outfile<<"    assign adder_add_cout["<<i<<"] = adder_and_"<<3*i-2<<" | "<<"adder_and_"<<3*i-1<<" | "<<"adder_and_"<<3*i<<";"<<endl;
        }
        
        else
        {
            outfile<<"    assign sel = !adder_add_cout["<<i-1<<"];"<<endl;
 
        }
    }
    outfile<<"endmodule"<<endl;
}

void BenchGenComparator::compRTL(int x)
{
    string location(getcwd(NULL,0));
    string verilogdirectory="/verilogGeneratedRTL/";
    location+=verilogdirectory;
    stringstream outfilename;
    string filename="RTL_Comparator";
    int fileint=x;
    outfilename << filename << fileint << "Bits.v";
    string f=outfilename.str();
    string finaloutputfilename;
    finaloutputfilename=location+f;
    //cout<<finaloutputfilename;
    ofstream outfile(finaloutputfilename);
    outfile<<"/*This Verilog is generated by BechGen software.*/\n"
    "/*Designed by University of Massachusetts, Amherst, VLSI CAD LAB, Cunxi Yu*/\n"
    "/*/  Copyright (c) 2014 Cunxi Yu. All rights reserved. */ \n"
    "/*Contact: ycunxi@umass.edu */"<<endl;
    outfile<<"module comparator"<<x-1<<"Bits(a,b,sel);"<<endl;
    outfile<<"  input ["<<x-1<<":0] a,b;"<<endl;
    outfile<<"  output sel;"<<endl;
    outfile<<"  reg sel;"<<endl;
    outfile<<"  always @(a or b)"<<endl;
    outfile<<"     begin"<<endl;
    outfile<<"         if(a>=b)\n"
          "            begin\n"
          "                sel <= 1'b0;\n"
          "            end\n"
          "         else\n"
          "            begin\n"
          "                sel <= 1'b1;\n"
          "            end\n"
          "     end\n"
    "endmodule"<<endl;
}
//Signed adder is not ready now


void BenchGenComparator::signedadder(int x)
{
     x--;

    cout<<"module adder"<<x+1<<"Bits(a,b,z);"<<endl;
    cout<<" input ["<<x+1<<":0] a,b;"<<endl;
    cout<<" output ["<<x+2<<":0] z;"<<endl;
    cout<<" wire ["<<x+2<<":0] z;"<<endl;
    cout<<" wire ["<<x<<":0] adder_add_cout;"<<endl;
    cout<<"    assign initial_and = a[0] & !b[0] ;"<<endl;
    cout<<"    assign initial_or = a[0] | !b[0]; "<<endl;
    cout<<"    assign adder_add_cout[0] = initial_or | initial_and ;"<<endl;
    for (int i=1; i<=x+1; i++) {
        if (i!=x+1) {
            cout<<"    assign adder_and"<<3*i-2<<" = adder_add_cout["<<i-1<<"] & a["<<i<<"];"<<endl;
            cout<<"    assign adder_and"<<3*i-1<<" = adder_add_cout["<<i-1<<"] & !b["<<i<<"];"<<endl;
            cout<<"    assign adder_and"<<3*i<<" = a["<<i<<"] & !b["<<i<<"];"<<endl;
            cout<<"    assign adder_or"<<i<<" = adder_and"<<3*i-2<<" | "<<"adder_and"<<3*i-1<<";"<<endl;
            cout<<"    assign adder_add_cout["<<i<<"] = adder_or"<<i<<" | ""adder_and"<<3*i<<";"<<endl;
            
            cout<<"    assign adder_xor"<<i<<" = a["<<i<<"] ^ !b["<<i<<"];"<<endl;
            cout<<"    assign z["<<i<<"] = adder_xor"<<i<<" ^ "<<"adder_add_cout["<<i-1<<"];"<<endl;
        }
        else
        {
            cout<<"    assign adder_and"<<3*i-2<<" = adder_add_cout["<<i-1<<"] & a["<<i<<"];"<<endl;
            cout<<"    assign adder_and"<<3*i-1<<" = adder_add_cout["<<i-1<<"] & !b["<<i<<"];"<<endl;
            cout<<"    assign adder_and"<<3*i<<" = a["<<i<<"] & !b["<<i<<"];"<<endl;
            cout<<"    assign adder_or"<<i<<" = adder_and"<<3*i-2<<" | "<<"adder_and"<<3*i-1<<" | "<<"adder_and"<<3*i<<";"<<endl;
            cout<<"    assign z["<<i+1<<"] = adder_or"<<i<<" | adder_and"<<3*i<<";"<<endl;
            cout<<"    assign adder_xor"<<i<<" = a["<<i<<"] ^ !b["<<i<<"];"<<endl;
            cout<<"    assign z["<<i<<"] = adder_xor"<<i<<" ^ "<<"adder_add_cout["<<i-1<<"];"<<endl;
        }
    }
    cout<<"endmodule"<<endl;
}


void max_comp1(int x)
//The gate level Verilog HDL code for Addition(in1+in2)
{
    x--;
    /*
     cout<<"module subtractor"<<x+1<<"Bits(a,b,sel);"<<endl;
     cout<<" input ["<<x<<":0] a,b;"<<endl;
     cout<<" output sel;"<<endl;
     cout<<" wire ["<<x<<":0] adder_add_cout;"<<endl;  */
    cout<<"    assign comp1_initial_and = a[0] & !b[0] ;"<<endl;
    cout<<"    assign comp1_initial_or = a[0] | !b[0]; "<<endl;
    cout<<"    assign comp1_adder_add_cout[0] = comp1_initial_or | comp1_initial_and ;"<<endl;
    for (int i=1; i<=x+1; i++) {
        if (i!=x+1) {
            
            
            cout<<"    assign comp1_adder_and"<<3*i-2<<" = comp1_adder_add_cout["<<i-1<<"] & a["<<i<<"];"<<endl;
            cout<<"    assign comp1_adder_and"<<3*i-1<<" = comp1_adder_add_cout["<<i-1<<"] & !b["<<i<<"];"<<endl;
            cout<<"    assign comp1_adder_and"<<3*i<<" = a["<<i<<"] & !b["<<i<<"];"<<endl;
            cout<<"    assign comp1_adder_or"<<i<<" = comp1_adder_and"<<3*i-2<<" | "<<"comp1_adder_and"<<3*i-1<<";"<<endl;
            cout<<"    assign comp1_adder_add_cout["<<i<<"] = comp1_adder_or"<<i<<" | comp1_adder_and"<<3*i<<";"<<endl;
            // cout<<"    assign comp1_adder_add_cout["<<i<<"] = adder_and_"<<3*i-2<<" | "<<"adder_and_"<<3*i-1<<" | "<<"adder_and_"<<3*i<<";"<<endl;
        }
        
        else
        {
            cout<<"    assign comp1_sel = !comp1_adder_add_cout["<<i-1<<"];"<<endl;
        }
    }
}

void max_mux1(int x)
{
    cout<<"    assign mux1_sbar = !comp1_sel;"<<endl;
    for (int i=1; i<=x; i++) {
        cout<<"    assign mux1_and"<<2*i-1<<" = a["<<i-1<<"] & mux1_sbar;"<<endl;
        cout<<"    assign mux1_and"<<2*i<<" = b["<<i-1<<"] & comp1_sel;"<<endl;
        cout<<"    assign mux1_out["<<i-1<<"] = mux1_and"<<2*i-1<<" | mux1_and"<<2*i<<";"<<endl;
    }
}

void max_comp2(int x)
{
    x--;
    cout<<"    assign comp2_initial_and = mux1_out[0] & !c[0] ;"<<endl;
    cout<<"    assign comp2_initial_or = mux1_out[0] | !c[0]; "<<endl;
    cout<<"    assign comp2_adder_add_cout[0] = comp2_initial_or | comp2_initial_and ;"<<endl;
    for (int i=1; i<=x+1; i++) {
        if (i!=x+1) {
            cout<<"    assign comp2_adder_and"<<3*i-2<<" = comp2_adder_add_cout["<<i-1<<"] & mux1_out["<<i<<"];"<<endl;
            cout<<"    assign comp2_adder_and"<<3*i-1<<" = comp2_adder_add_cout["<<i-1<<"] & !c["<<i<<"];"<<endl;
            cout<<"    assign comp2_adder_and"<<3*i<<" = mux1_out["<<i<<"] & !c["<<i<<"];"<<endl;
            cout<<"    assign comp2_adder_or"<<i<<" = comp2_adder_and"<<3*i-2<<" | "<<"comp2_adder_and"<<3*i-1<<";"<<endl;
            cout<<"    assign comp2_adder_add_cout["<<i<<"] = comp2_adder_or"<<i<<" | comp2_adder_and"<<3*i<<";"<<endl;
        }
        else
        {
            cout<<"    assign comp2_sel = !comp2_adder_add_cout["<<i-1<<"];"<<endl;
        }
    }
}

void max_mux2(int x)
{
    cout<<"    assign mux2_sbar = !comp2_sel;"<<endl;
    for (int i=1; i<=x; i++) {
        cout<<"    assign mux2_and"<<2*i-1<<" = mux1_out["<<i-1<<"] & mux2_sbar;"<<endl;
        cout<<"    assign mux2_and"<<2*i<<" = c["<<i-1<<"] & comp2_sel;"<<endl;
        cout<<"    assign mux2_out["<<i-1<<"] = mux2_and"<<2*i-1<<" | mux2_and"<<2*i<<";"<<endl;
    }
}

void max_comp3(int x)
{
    x--;
    cout<<"    assign comp3_initial_and = mux2_out[0] & !d[0] ;"<<endl;
    cout<<"    assign comp3_initial_or = mux2_out[0] | !d[0]; "<<endl;
    cout<<"    assign comp3_adder_add_cout[0] = comp3_initial_or | comp3_initial_and ;"<<endl;
    for (int i=1; i<=x+1; i++) {
        if (i!=x+1) {
            cout<<"    assign comp3_adder_and"<<3*i-2<<" = comp3_adder_add_cout["<<i-1<<"] & mux2_out["<<i<<"];"<<endl;
            cout<<"    assign comp3_adder_and"<<3*i-1<<" = comp3_adder_add_cout["<<i-1<<"] & !d["<<i<<"];"<<endl;
            cout<<"    assign comp3_adder_and"<<3*i<<" = mux2_out["<<i<<"] & !d["<<i<<"];"<<endl;
            cout<<"    assign comp3_adder_or"<<i<<" = comp3_adder_and"<<3*i-2<<" | "<<"comp3_adder_and"<<3*i-1<<";"<<endl;
            cout<<"    assign comp3_adder_add_cout["<<i<<"] = comp3_adder_or"<<i<<" | comp3_adder_and"<<3*i<<";"<<endl;
        }
        else
        {
            cout<<"    assign comp3_sel = !comp3_adder_add_cout["<<i-1<<"];"<<endl;
        }
    }
}

void max_mux3(int x)
{
    cout<<"    assign mux3_sbar = !comp3_sel;"<<endl;
    for (int i=1; i<=x; i++) {
        cout<<"    assign mux3_and"<<2*i-1<<" = mux2_out["<<i-1<<"] & mux3_sbar;"<<endl;
        cout<<"    assign mux3_and"<<2*i<<" = d["<<i-1<<"] & comp3_sel;"<<endl;
        cout<<"    assign max_out["<<i-1<<"] = mux3_and"<<2*i-1<<" | mux3_and"<<2*i<<";"<<endl;
    }
}
void max_number(int x)
{
    cout<<"/*This Verilog is generated by BechGen software.*/\n"
    "/*Designed by University of Massachusetts, Amherst, VLSI CAD LAB, Cunxi Yu*/\n"
    "/*/  Copyright (c) 2014 Cunxi Yu. All rights reserved. */ \n"
    "/*Contact: ycunxi@umass.edu */"<<endl;
    cout<<"module FindMaxNumber"<<x<<"bits(a,b,c,d,max_out);"<<endl;
    cout<<"input ["<<x-1<<":0] a,b,c,d;"<<endl;
    cout<<"output ["<<x-1<<":0] max_out;"<<endl;
    cout<<"wire ["<<x-1<<":0] max_out,comp1_adder_add_cout,comp2_adder_add_cout,comp3_adder_add_cout,mux1_out,mux2_out,mux3_out;"<<endl;
    
    max_comp1(x);
    max_mux1(x);
    max_comp2(x);
    max_mux2(x);
    max_comp3(x);
    max_mux3(x);
    cout<<"endmodule"<<endl;
}

void min_comp1(int x)
//The gate level Verilog HDL code for Addition(in1+in2)
{
    x--;
    /*
     cout<<"module subtractor"<<x+1<<"Bits(a,b,sel);"<<endl;
     cout<<" input ["<<x<<":0] a,b;"<<endl;
     cout<<" output sel;"<<endl;
     cout<<" wire ["<<x<<":0] adder_add_cout;"<<endl;  */
    cout<<"    assign comp1_initial_and = a[0] & !b[0] ;"<<endl;
    cout<<"    assign comp1_initial_or = a[0] | !b[0]; "<<endl;
    cout<<"    assign comp1_adder_add_cout[0] = comp1_initial_or | comp1_initial_and ;"<<endl;
    for (int i=1; i<=x+1; i++) {
        if (i!=x+1) {
            
            
            cout<<"    assign comp1_adder_and"<<3*i-2<<" = comp1_adder_add_cout["<<i-1<<"] & a["<<i<<"];"<<endl;
            cout<<"    assign comp1_adder_and"<<3*i-1<<" = comp1_adder_add_cout["<<i-1<<"] & !b["<<i<<"];"<<endl;
            cout<<"    assign comp1_adder_and"<<3*i<<" = a["<<i<<"] & !b["<<i<<"];"<<endl;
            cout<<"    assign comp1_adder_or"<<i<<" = comp1_adder_and"<<3*i-2<<" | "<<"comp1_adder_and"<<3*i-1<<";"<<endl;
            cout<<"    assign comp1_adder_add_cout["<<i<<"] = comp1_adder_or"<<i<<" | comp1_adder_and"<<3*i<<";"<<endl;
            // cout<<"    assign comp1_adder_add_cout["<<i<<"] = adder_and_"<<3*i-2<<" | "<<"adder_and_"<<3*i-1<<" | "<<"adder_and_"<<3*i<<";"<<endl;
        }
        
        else
        {
            cout<<"    assign comp1_sel = comp1_adder_add_cout["<<i-1<<"];"<<endl;
        }
    }
}

void min_mux1(int x)
{
    cout<<"    assign mux1_sbar = !comp1_sel;"<<endl;
    for (int i=1; i<=x; i++) {
        cout<<"    assign mux1_and"<<2*i-1<<" = a["<<i-1<<"] & mux1_sbar;"<<endl;
        cout<<"    assign mux1_and"<<2*i<<" = b["<<i-1<<"] & comp1_sel;"<<endl;
        cout<<"    assign mux1_out["<<i-1<<"] = mux1_and"<<2*i-1<<" | mux1_and"<<2*i<<";"<<endl;
    }
}

void min_comp2(int x)
{
    x--;
    cout<<"    assign comp2_initial_and = mux1_out[0] & !c[0] ;"<<endl;
    cout<<"    assign comp2_initial_or = mux1_out[0] | !c[0]; "<<endl;
    cout<<"    assign comp2_adder_add_cout[0] = comp2_initial_or | comp2_initial_and ;"<<endl;
    for (int i=1; i<=x+1; i++) {
        if (i!=x+1) {
            cout<<"    assign comp2_adder_and"<<3*i-2<<" = comp2_adder_add_cout["<<i-1<<"] & mux1_out["<<i<<"];"<<endl;
            cout<<"    assign comp2_adder_and"<<3*i-1<<" = comp2_adder_add_cout["<<i-1<<"] & !c["<<i<<"];"<<endl;
            cout<<"    assign comp2_adder_and"<<3*i<<" = mux1_out["<<i<<"] & !c["<<i<<"];"<<endl;
            cout<<"    assign comp2_adder_or"<<i<<" = comp2_adder_and"<<3*i-2<<" | "<<"comp2_adder_and"<<3*i-1<<";"<<endl;
            cout<<"    assign comp2_adder_add_cout["<<i<<"] = comp2_adder_or"<<i<<" | comp2_adder_and"<<3*i<<";"<<endl;
        }
        else
        {
            cout<<"    assign comp2_sel = comp2_adder_add_cout["<<i-1<<"];"<<endl;
        }
    }
}

void min_mux2(int x)
{
    cout<<"    assign mux2_sbar = !comp2_sel;"<<endl;
    for (int i=1; i<=x; i++) {
        cout<<"    assign mux2_and"<<2*i-1<<" = mux1_out["<<i-1<<"] & mux2_sbar;"<<endl;
        cout<<"    assign mux2_and"<<2*i<<" = c["<<i-1<<"] & comp2_sel;"<<endl;
        cout<<"    assign mux2_out["<<i-1<<"] = mux2_and"<<2*i-1<<" | mux2_and"<<2*i<<";"<<endl;
    }
}

void min_comp3(int x)
{
    x--;
    cout<<"    assign comp3_initial_and = mux2_out[0] & !d[0] ;"<<endl;
    cout<<"    assign comp3_initial_or = mux2_out[0] | !d[0]; "<<endl;
    cout<<"    assign comp3_adder_add_cout[0] = comp3_initial_or | comp3_initial_and ;"<<endl;
    for (int i=1; i<=x+1; i++) {
        if (i!=x+1) {
            cout<<"    assign comp3_adder_and"<<3*i-2<<" = comp3_adder_add_cout["<<i-1<<"] & mux2_out["<<i<<"];"<<endl;
            cout<<"    assign comp3_adder_and"<<3*i-1<<" = comp3_adder_add_cout["<<i-1<<"] & !d["<<i<<"];"<<endl;
            cout<<"    assign comp3_adder_and"<<3*i<<" = mux2_out["<<i<<"] & !d["<<i<<"];"<<endl;
            cout<<"    assign comp3_adder_or"<<i<<" = comp3_adder_and"<<3*i-2<<" | "<<"comp3_adder_and"<<3*i-1<<";"<<endl;
            cout<<"    assign comp3_adder_add_cout["<<i<<"] = comp3_adder_or"<<i<<" | comp3_adder_and"<<3*i<<";"<<endl;
        }
        else
        {
            cout<<"    assign comp3_sel = comp3_adder_add_cout["<<i-1<<"];"<<endl;
        }
    }
}

void min_mux3(int x)
{
    cout<<"    assign mux3_sbar = !comp3_sel;"<<endl;
    for (int i=1; i<=x; i++) {
        cout<<"    assign mux3_and"<<2*i-1<<" = mux2_out["<<i-1<<"] & mux3_sbar;"<<endl;
        cout<<"    assign mux3_and"<<2*i<<" = d["<<i-1<<"] & comp3_sel;"<<endl;
        cout<<"    assign min_out["<<i-1<<"] = mux3_and"<<2*i-1<<" | mux3_and"<<2*i<<";"<<endl;
    }
}
void min_number(int x)
{
    cout<<"/*This Verilog is generated by BechGen software.*/\n"
    "/*Designed by University of Massachusetts, Amherst, VLSI CAD LAB, Cunxi Yu*/\n"
    "/*/  Copyright (c) 2014 Cunxi Yu. All rights reserved. */ \n"
    "/*Contact: ycunxi@umass.edu */"<<endl;
    cout<<"module FindMinNumber"<<x<<"bits(a,b,c,d,min_out);"<<endl;
    cout<<"input ["<<x-1<<":0] a,b,c,d;"<<endl;
    cout<<"output ["<<x-1<<":0] min_out;"<<endl;
    cout<<"wire ["<<x-1<<":0] min_out,comp1_adder_add_cout,comp2_adder_add_cout,comp3_adder_add_cout,mux1_out,mux2_out,mux3_out;"<<endl;
    
    min_comp1(x);
    min_mux1(x);
    min_comp2(x);
    min_mux2(x);
    min_comp3(x);
    min_mux3(x);
    cout<<"endmodule"<<endl;
}

void BenchGenComparator::FindMaxNumber(int x)
{
    max_number(x);
}

void BenchGenComparator::FindMinNumber(int x)
{
    min_number(x);
}

void BenchGenComparator::FindMaxNumberRTL(int x)
{
    cout<<"/*This Verilog is generated by BechGen software.*/\n"
    "/*Designed by University of Massachusetts, Amherst, VLSI CAD LAB, Cunxi Yu*/\n"
    "/*/  Copyright (c) 2014 Cunxi Yu. All rights reserved. */ \n"
    "/*Contact: ycunxi@umass.edu */"<<endl;
    cout<<"module FindMaxNumberRTL(a,b,c,d,max_out);"<<endl;
    cout<<"  input ["<<x-1<<":0] a,b,c,d;"<<endl;
    cout<<"  output ["<<x-1<<":0] max_out;"<<endl;
    cout<<"  reg ["<<x-1<<":0] max_out;"<<endl;
    cout<<"  always @(a or b or c or d)"<<endl;
    cout<<"  begin\n";
    cout<<"    if(a>=b && a>=c && a>=d)\n"
          "      max_out<=a;\n"
          "    else if(b>=a && b>=c && b>=d)\n"
          "      max_out<=b;\n"
          "    else if(c>=a && c>=b && c>=d)\n"
          "      max_out<=c;\n"
          "    else\n"
          "      max_out<=d;\n"
          "  end\n"
          "endmodule"<<endl;
}

void BenchGenComparator::FindMinNumberRTL(int x)
{
    cout<<"/*This Verilog is generated by BechGen software.*/\n"
    "/*Designed by University of Massachusetts, Amherst, VLSI CAD LAB, Cunxi Yu*/\n"
    "/*/  Copyright (c) 2014 Cunxi Yu. All rights reserved. */ \n"
    "/*Contact: ycunxi@umass.edu */"<<endl;
    cout<<"module FindMaxNumberRTL(a,b,c,d,max_out);"<<endl;
    cout<<"  input ["<<x-1<<":0] a,b,c,d;"<<endl;
    cout<<"  output ["<<x-1<<":0] max_out;"<<endl;
    cout<<"  reg ["<<x-1<<":0] max_out;"<<endl;
    cout<<"  always @(a or b or c or d)"<<endl;
    cout<<"  begin\n";
    cout<<"    if(a<=b && a<=c && a<=d)\n"
    "      max_out<=a;\n"
    "    else if(b<=a && b<=c && b<=d)\n"
    "      max_out<=b;\n"
    "    else if(c<=a && c<=b && c<=d)\n"
    "      max_out<=c;\n"
    "    else\n"
    "      max_out<=d;\n"
    "  end\n"
    "endmodule"<<endl;
}

void mean_max_comp1(int x)
//The gate level Verilog HDL code for Addition(in1+in2)
{
    x--;
    /*
     cout<<"module subtractor"<<x+1<<"Bits(a,b,sel);"<<endl;
     cout<<" input ["<<x<<":0] a,b;"<<endl;
     cout<<" output sel;"<<endl;
     cout<<" wire ["<<x<<":0] adder_add_cout;"<<endl;  */
    cout<<"    assign comp1_initial_and = a[0] & !b[0] ;"<<endl;
    cout<<"    assign comp1_initial_or = a[0] | !b[0]; "<<endl;
    cout<<"    assign comp1_adder_add_cout[0] = comp1_initial_or | comp1_initial_and ;"<<endl;
    for (int i=1; i<=x+1; i++) {
        if (i!=x+1) {
            
            
            cout<<"    assign comp1_adder_and"<<3*i-2<<" = comp1_adder_add_cout["<<i-1<<"] & a["<<i<<"];"<<endl;
            cout<<"    assign comp1_adder_and"<<3*i-1<<" = comp1_adder_add_cout["<<i-1<<"] & !b["<<i<<"];"<<endl;
            cout<<"    assign comp1_adder_and"<<3*i<<" = a["<<i<<"] & !b["<<i<<"];"<<endl;
            cout<<"    assign comp1_adder_or"<<i<<" = comp1_adder_and"<<3*i-2<<" | "<<"comp1_adder_and"<<3*i-1<<";"<<endl;
            cout<<"    assign comp1_adder_add_cout["<<i<<"] = comp1_adder_or"<<i<<" | comp1_adder_and"<<3*i<<";"<<endl;
            // cout<<"    assign comp1_adder_add_cout["<<i<<"] = adder_and_"<<3*i-2<<" | "<<"adder_and_"<<3*i-1<<" | "<<"adder_and_"<<3*i<<";"<<endl;
        }
        
        else
        {
            cout<<"    assign comp1_sel = !comp1_adder_add_cout["<<i-1<<"];"<<endl;
        }
    }
}

void mean_max_mux1(int x)
{
    cout<<"    assign mux1_sbar = !comp1_sel;"<<endl;
    for (int i=1; i<=x; i++) {
        cout<<"    assign mux1_and"<<2*i-1<<" = a["<<i-1<<"] & mux1_sbar;"<<endl;
        cout<<"    assign mux1_and"<<2*i<<" = b["<<i-1<<"] & comp1_sel;"<<endl;
        cout<<"    assign mux1_out["<<i-1<<"] = mux1_and"<<2*i-1<<" | mux1_and"<<2*i<<";"<<endl;
    }
}

void mean_max_comp2(int x)
{
    x--;
    cout<<"    assign comp2_initial_and = mux1_out[0] & !c[0] ;"<<endl;
    cout<<"    assign comp2_initial_or = mux1_out[0] | !c[0]; "<<endl;
    cout<<"    assign comp2_adder_add_cout[0] = comp2_initial_or | comp2_initial_and ;"<<endl;
    for (int i=1; i<=x+1; i++) {
        if (i!=x+1) {
            cout<<"    assign comp2_adder_and"<<3*i-2<<" = comp2_adder_add_cout["<<i-1<<"] & mux1_out["<<i<<"];"<<endl;
            cout<<"    assign comp2_adder_and"<<3*i-1<<" = comp2_adder_add_cout["<<i-1<<"] & !c["<<i<<"];"<<endl;
            cout<<"    assign comp2_adder_and"<<3*i<<" = mux1_out["<<i<<"] & !c["<<i<<"];"<<endl;
            cout<<"    assign comp2_adder_or"<<i<<" = comp2_adder_and"<<3*i-2<<" | "<<"comp2_adder_and"<<3*i-1<<";"<<endl;
            cout<<"    assign comp2_adder_add_cout["<<i<<"] = comp2_adder_or"<<i<<" | comp2_adder_and"<<3*i<<";"<<endl;
        }
        else
        {
            cout<<"    assign comp2_sel = !comp2_adder_add_cout["<<i-1<<"];"<<endl;
        }
    }
}

void mean_max_mux2(int x)
{
    cout<<"    assign mux2_sbar = !comp2_sel;"<<endl;
    for (int i=1; i<=x; i++) {
        cout<<"    assign mux2_and"<<2*i-1<<" = mux1_out["<<i-1<<"] & mux2_sbar;"<<endl;
        cout<<"    assign mux2_and"<<2*i<<" = c["<<i-1<<"] & comp2_sel;"<<endl;
        cout<<"    assign mux2_out["<<i-1<<"] = mux2_and"<<2*i-1<<" | mux2_and"<<2*i<<";"<<endl;
    }
}

void mean_max_comp3(int x)
{
    x--;
    cout<<"    assign comp3_initial_and = mux2_out[0] & !d[0] ;"<<endl;
    cout<<"    assign comp3_initial_or = mux2_out[0] | !d[0]; "<<endl;
    cout<<"    assign comp3_adder_add_cout[0] = comp3_initial_or | comp3_initial_and ;"<<endl;
    for (int i=1; i<=x+1; i++) {
        if (i!=x+1) {
            cout<<"    assign comp3_adder_and"<<3*i-2<<" = comp3_adder_add_cout["<<i-1<<"] & mux2_out["<<i<<"];"<<endl;
            cout<<"    assign comp3_adder_and"<<3*i-1<<" = comp3_adder_add_cout["<<i-1<<"] & !d["<<i<<"];"<<endl;
            cout<<"    assign comp3_adder_and"<<3*i<<" = mux2_out["<<i<<"] & !d["<<i<<"];"<<endl;
            cout<<"    assign comp3_adder_or"<<i<<" = comp3_adder_and"<<3*i-2<<" | "<<"comp3_adder_and"<<3*i-1<<";"<<endl;
            cout<<"    assign comp3_adder_add_cout["<<i<<"] = comp3_adder_or"<<i<<" | comp3_adder_and"<<3*i<<";"<<endl;
        }
        else
        {
            cout<<"    assign comp3_sel = !comp3_adder_add_cout["<<i-1<<"];"<<endl;
        }
    }
}

void mean_max_mux3(int x)
{
    cout<<"    assign mux3_sbar = !comp3_sel;"<<endl;
    for (int i=1; i<=x; i++) {
        cout<<"    assign mux3_and"<<2*i-1<<" = mux2_out["<<i-1<<"] & mux3_sbar;"<<endl;
        cout<<"    assign mux3_and"<<2*i<<" = d["<<i-1<<"] & comp3_sel;"<<endl;
        cout<<"    assign max_out["<<i-1<<"] = mux3_and"<<2*i-1<<" | mux3_and"<<2*i<<";"<<endl;
    }
}
void mean_max_number(int x)
{
    
    
    
    mean_max_comp1(x);
    mean_max_mux1(x);
    mean_max_comp2(x);
    mean_max_mux2(x);
    mean_max_comp3(x);
    mean_max_mux3(x);
    
}

void mean_min_comp1(int x)
//The gate level Verilog HDL code for Addition(in1+in2)
{
    x--;
    
    cout<<"    assign comp4_initial_and = a[0] & !b[0] ;"<<endl;
    cout<<"    assign comp4_initial_or = a[0] | !b[0]; "<<endl;
    cout<<"    assign comp4_adder_add_cout[0] = comp4_initial_or | comp4_initial_and ;"<<endl;
    for (int i=1; i<=x+1; i++) {
        if (i!=x+1) {
            
            
            cout<<"    assign comp4_adder_and"<<3*i-2<<" = comp4_adder_add_cout["<<i-1<<"] & a["<<i<<"];"<<endl;
            cout<<"    assign comp4_adder_and"<<3*i-1<<" = comp4_adder_add_cout["<<i-1<<"] & !b["<<i<<"];"<<endl;
            cout<<"    assign comp4_adder_and"<<3*i<<" = a["<<i<<"] & !b["<<i<<"];"<<endl;
            cout<<"    assign comp4_adder_or"<<i<<" = comp4_adder_and"<<3*i-2<<" | "<<"comp4_adder_and"<<3*i-1<<";"<<endl;
            cout<<"    assign comp4_adder_add_cout["<<i<<"] = comp4_adder_or"<<i<<" | comp4_adder_and"<<3*i<<";"<<endl;
            
        }
        
        else
        {
            cout<<"    assign comp4_sel = comp4_adder_add_cout["<<i-1<<"];"<<endl;
        }
    }
}

void mean_min_mux1(int x)
{
    cout<<"    assign mux4_sbar = !comp4_sel;"<<endl;
    for (int i=1; i<=x; i++) {
        cout<<"    assign mux4_and"<<2*i-1<<" = a["<<i-1<<"] & mux4_sbar;"<<endl;
        cout<<"    assign mux4_and"<<2*i<<" = b["<<i-1<<"] & comp4_sel;"<<endl;
        cout<<"    assign mux4_out["<<i-1<<"] = mux4_and"<<2*i-1<<" | mux4_and"<<2*i<<";"<<endl;
    }
}

void mean_min_comp2(int x)
{
    x--;
    cout<<"    assign comp5_initial_and = mux4_out[0] & !c[0] ;"<<endl;
    cout<<"    assign comp5_initial_or = mux4_out[0] | !c[0]; "<<endl;
    cout<<"    assign comp5_adder_add_cout[0] = comp5_initial_or | comp5_initial_and ;"<<endl;
    for (int i=1; i<=x+1; i++) {
        if (i!=x+1) {
            cout<<"    assign comp5_adder_and"<<3*i-2<<" = comp5_adder_add_cout["<<i-1<<"] & mux4_out["<<i<<"];"<<endl;
            cout<<"    assign comp5_adder_and"<<3*i-1<<" = comp5_adder_add_cout["<<i-1<<"] & !c["<<i<<"];"<<endl;
            cout<<"    assign comp5_adder_and"<<3*i<<" = mux4_out["<<i<<"] & !c["<<i<<"];"<<endl;
            cout<<"    assign comp5_adder_or"<<i<<" = comp5_adder_and"<<3*i-2<<" | "<<"comp5_adder_and"<<3*i-1<<";"<<endl;
            cout<<"    assign comp5_adder_add_cout["<<i<<"] = comp5_adder_or"<<i<<" | comp5_adder_and"<<3*i<<";"<<endl;
        }
        else
        {
            cout<<"    assign comp5_sel = comp5_adder_add_cout["<<i-1<<"];"<<endl;
        }
    }
}

void mean_min_mux2(int x)
{
    cout<<"    assign mux5_sbar = !comp5_sel;"<<endl;
    for (int i=1; i<=x; i++) {
        cout<<"    assign mux5_and"<<2*i-1<<" = mux4_out["<<i-1<<"] & mux5_sbar;"<<endl;
        cout<<"    assign mux5_and"<<2*i<<" = c["<<i-1<<"] & comp5_sel;"<<endl;
        cout<<"    assign mux5_out["<<i-1<<"] = mux5_and"<<2*i-1<<" | mux5_and"<<2*i<<";"<<endl;
    }
}

void mean_min_comp3(int x)
{
    x--;
    cout<<"    assign comp6_initial_and = mux5_out[0] & !d[0] ;"<<endl;
    cout<<"    assign comp6_initial_or = mux5_out[0] | !d[0]; "<<endl;
    cout<<"    assign comp6_adder_add_cout[0] = comp6_initial_or | comp6_initial_and ;"<<endl;
    for (int i=1; i<=x+1; i++) {
        if (i!=x+1) {
            cout<<"    assign comp6_adder_and"<<3*i-2<<" = comp6_adder_add_cout["<<i-1<<"] & mux5_out["<<i<<"];"<<endl;
            cout<<"    assign comp6_adder_and"<<3*i-1<<" = comp6_adder_add_cout["<<i-1<<"] & !d["<<i<<"];"<<endl;
            cout<<"    assign comp6_adder_and"<<3*i<<" = mux5_out["<<i<<"] & !d["<<i<<"];"<<endl;
            cout<<"    assign comp6_adder_or"<<i<<" = comp6_adder_and"<<3*i-2<<" | "<<"comp6_adder_and"<<3*i-1<<";"<<endl;
            cout<<"    assign comp6_adder_add_cout["<<i<<"] = comp6_adder_or"<<i<<" | comp6_adder_and"<<3*i<<";"<<endl;
        }
        else
        {
            cout<<"    assign comp6_sel = comp6_adder_add_cout["<<i-1<<"];"<<endl;
        }
    }
}

void mean_min_mux3(int x)
{
    cout<<"    assign mux6_sbar = !comp6_sel;"<<endl;
    for (int i=1; i<=x; i++) {
        cout<<"    assign mux6_and"<<2*i-1<<" = mux5_out["<<i-1<<"] & mux6_sbar;"<<endl;
        cout<<"    assign mux6_and"<<2*i<<" = d["<<i-1<<"] & comp6_sel;"<<endl;
        cout<<"    assign min_out["<<i-1<<"] = mux6_and"<<2*i-1<<" | mux6_and"<<2*i<<";"<<endl;
    }
}
void mean_RightShift1bit(int x)
{
    cout<<"    assign s = 1'b0;"<<endl;
    cout<<"    assign s_bar = !s;"<<endl;
    for (int mux=1; mux<=x; mux++) {
        if (mux!=x) {
            cout<<"    assign and"<<2*mux-1<<" = mean_add_sum["<<mux-1<<"] & s;"<<endl;
            cout<<"    assign and"<<2*mux<<" = mean_add_sum["<<mux<<"] & s_bar;"<<endl;
            cout<<"    assign z["<<mux-1<<"] = and"<<2*mux-1<<" | and"<<2*mux<<";"<<endl;
        }
        else
        {
            cout<<"    assign and"<<2*mux-1<<" = mean_add_sum["<<mux-1<<"] & s;"<<endl;
            cout<<"    assign and"<<2*mux<<" = 1'b0 & s_bar;"<<endl;
            cout<<"    assign z["<<mux-1<<"] = and"<<2*mux-1<<" | and"<<2*mux<<";"<<endl;
        }
    }
    
}
void mean_MeanNumberAdd(int x)
{
    x--;
    cout<<"    assign mean_add_and0 = max_out[0] & min_out[0];"<<endl;
    cout<<"    assign mean_add_cout[0] = mean_add_and0;"<<endl;
    cout<<"    assign mean_add_sum[0] = max_out[0] ^ min_out[0];"<<endl;
    for (int i=1; i<=x; i++) {
        if (i!=x) {
            cout<<"    assign mean_add_and"<<3*i-2<<" = mean_add_cout["<<i-1<<"] & max_out["<<i<<"];"<<endl;
            cout<<"    assign mean_add_and"<<3*i-1<<" = mean_add_cout["<<i-1<<"] & min_out["<<i<<"];"<<endl;
            cout<<"    assign mean_add_and"<<3*i<<" = max_out["<<i<<"] & min_out["<<i<<"];"<<endl;
            cout<<"    assign mean_add_or"<<i<<" = mean_add_and"<<3*i-2<<" | "<<"mean_add_and"<<3*i-1<<";"<<endl;
            cout<<"    assign mean_add_cout["<<i<<"] = mean_add_or"<<i<<" | ""mean_add_and"<<3*i<<";"<<endl;
            
            cout<<"    assign mean_add_xor"<<i<<" = max_out["<<i<<"] ^ min_out["<<i<<"];"<<endl;
            cout<<"    assign mean_add_sum["<<i<<"] = mean_add_xor"<<i<<" ^ "<<"mean_add_cout["<<i-1<<"];"<<endl;
        }
        else
        {
            cout<<"    assign mean_add_and"<<3*i-2<<" = mean_add_cout["<<i-1<<"] & max_out["<<i<<"];"<<endl;
            cout<<"    assign mean_add_and"<<3*i-1<<" = mean_add_cout["<<i-1<<"] & min_out["<<i<<"];"<<endl;
            cout<<"    assign mean_add_and"<<3*i<<" = max_out["<<i<<"] & min_out["<<i<<"];"<<endl;
            cout<<"    assign mean_add_or"<<i<<" = mean_add_and"<<3*i-2<<" | "<<"mean_add_and"<<3*i-1<<";"<<endl;
            cout<<"    assign mean_add_sum["<<i+1<<"] = mean_add_or"<<i<<" | mean_add_and"<<3*i<<";"<<endl;
            cout<<"    assign mean_add_xor"<<i<<" = max_out["<<i<<"] ^ min_out["<<i<<"];"<<endl;
            cout<<"    assign mean_add_sum["<<i<<"] = mean_add_xor"<<i<<" ^ "<<"mean_add_cout["<<i-1<<"];"<<endl;
        }
    }
}
void mean_min_number(int x)
{
    mean_min_comp1(x);
    mean_min_mux1(x);
    mean_min_comp2(x);
    mean_min_mux2(x);
    mean_min_comp3(x);
    mean_min_mux3(x);
    
    
}

void BenchGenComparator::FindMeanNumber(int x)
{
    cout<<"/*This Verilog is generated by BechGen software.*/\n"
    "/*Designed by University of Massachusetts, Amherst, VLSI CAD LAB, Cunxi Yu*/\n"
    "/*/  Copyright (c) 2014 Cunxi Yu. All rights reserved. */ \n"
    "/*Contact: ycunxi@umass.edu */"<<endl;
    cout<<"module MeanNumber(a,b,c,d,z);"<<endl;
    cout<<"  input ["<<x-1<<":0] a,b,c,d;"<<endl;
    cout<<"  output ["<<x<<":0] z;"<<endl;
    cout<<"  wire ["<<x<<":0] z;"<<endl;
    cout<<"  wire ["<<x-1<<":0] max_out,comp1_adder_add_cout,comp2_adder_add_cout,comp3_adder_add_cout,mux1_out,mux2_out,mux3_out;"<<endl;
    cout<<"  wire ["<<x-1<<":0] min_out,comp4_adder_add_cout,comp5_adder_add_cout,comp6_adder_add_cout,mux4_out,mux5_out,mux6_out;"<<endl;
    cout<<"  wire ["<<x+1<<":0] mean_add_sum;"<<endl;
    cout<<"  wire ["<<x-1<<":0] mean_add_cout;"<<endl;
    mean_max_number(x);
    mean_min_number(x);
    mean_MeanNumberAdd(x);
    mean_RightShift1bit(x+1);
    cout<<"endmodule"<<endl;
}

void BenchGenComparator::FindMeanNumberRTL(int x)
{
    cout<<"/*This Verilog is generated by BechGen software.*/\n"
    "/*Designed by University of Massachusetts, Amherst, VLSI CAD LAB, Cunxi Yu*/\n"
    "/*/  Copyright (c) 2014 Cunxi Yu. All rights reserved. */ \n"
    "/*Contact: ycunxi@umass.edu */"<<endl;
    cout<<"module FindMeanNumberRTL"<<x-1<<"(a,b,c,d,mean_out);"<<endl;
    cout<<"  input ["<<x-1<<":0] a,b,c,d;"<<endl;
    cout<<"  output ["<<x<<":0] mean_out;"<<endl;
    cout<<"  wire ["<<x<<":0] mean_out;"<<endl;
    cout<<"  reg ["<<x-1<<":0] max_out,min_out;"<<endl;
    cout<<"    always @(a or b or c or d)"<<endl;
    cout<<"    begin"<<endl;
    cout<<"     begin"<<endl;
    cout<<"     if(a>=b && a>=c && a>=d)"<<endl;
    cout<<"       max_out<=a;"<<endl;
    cout<<"     else if(b>=a && b>=c && b>=d)"<<endl;
    cout<<"       max_out<=b;"<<endl;
    cout<<"     else if(c>=a && c>=b && c>=d)"<<endl;
    cout<<"       max_out<=c;"<<endl;
    cout<<"     else"<<endl;
    cout<<"       max_out<=d;"<<endl;
    cout<<"     end"<<endl;
    cout<<"     begin"<<endl;
    cout<<"     if(a<=b && a<=c && a<=d)"<<endl;
    cout<<"       min_out<=a;"<<endl;
    cout<<"     else if(b<=a && b<=c && b<=d)"<<endl;
    cout<<"       min_out<=b;"<<endl;
    cout<<"     else if(c<=a && c<=b && c<=d)"<<endl;
    cout<<"       min_out<=c;"<<endl;
    cout<<"     else"<<endl;
    cout<<"       min_out<=d;"<<endl;
    cout<<"     end"<<endl;
    cout<<"   end"<<endl;
    cout<<"    assign  mean_out=(min_out+max_out)/2;"<<endl;
    cout<<"endmodule"<<endl;
}

void BenchGenComparator::GenMathModelofComparator(int bit)
{
    
    
   // cin>>bit;
    bit--;
    int s=bit;
   
    for (int sig_out=0; sig_out<=bit; sig_out++) {
        cout<<"y"<<sig_out;
        if (sig_out!=bit) {
            cout<<"+";
        }
    }
    cout<<endl;
    for (int i1=bit; i1>=0; i1--) {
        for (int i2=bit+2;i2>s+1;i2--) {
            if (i2==bit+2) {
            cout<<"y"<<i1<<" = b"<<i1<<"*(a"<<i1<<"+b"<<i1<<"-2*a"<<i1<<"*b"<<i1<<")";
                
            }
            else
            {
                cout<<"*(1-(a"<<i2-1<<" + b"<<i2-1<<"- 2*a"<<i2-1<<"*b"<<i2-1<<"))";
            }
        }
        s--;
        cout<<endl;
    }
}  
