//  BenchmarkGenerator
//  Created by Cunxi Yu on 7/12/14.
//  StringMath.h: The "verify" function library which is designed by Walter Brown on 06/2014.
//  Thanks to everyone in Maciej Ciesielski's group(Duo Liu, Walter Brown, Prof.Maciej Ciesielski).
//  Copyright (c) 2014 Cunxi Yu. All rights reserved.
//  Type "-help" to find the commands you need. Enjor!

#include <iostream>
#include <fstream>
#include <unistd.h>
#include <sstream>
#include <string>
#include <stdio.h>
#include "BenchGen.h"
using namespace std;

void BenchGen::welcomeTile()
{
    cout<<"//**  Welcome to BenchmarkGenerator **//\n"
    "//**  BenchmarkGenerator Verision 2.0 **//\n"
    "//**  Updated by Cunxi Yu on 01/13/2015. Co-Designed with Walter Brown, Duo Liu **//\n"
    "//**  Word-level MUX : F= S? A:B  **//\n"
    "//**  Last release : Design compiler verilogToBlif parse. Carry Look-ahead adder modeling.**//\n"
    "//**  Thanks to everyone in Maciej Ciesielski's group(Duo Liu, Walter Brown, Prof.Maciej Ciesielski).**//\n"
    "//**  University of Massachusetts,Amherst **//"
    "//**  Copyright (c) 2014 Cunxi Yu. All rights reserved.**//\n"
    "//**  Type "<<"help"<<" to check the commands. Type exit to exit the software **//"<<endl;
}

void verilogFile()
{
    cout<<"/*This Verilog is generated by BechGen software.*/\n"
          "/*Designed by University of Massachusetts, Amherst, VLSI CAD LAB, Cunxi Yu*/\n"
          "/*/  Copyright (c) 2014 Cunxi Yu. All rights reserved. */ \n"
           "/*Contact: ycunxi@umass.edu */"<<endl;
}

void BenchGen::MixhighlevelRTL(int x)
//a*b+a*c
{
    string location(getcwd(NULL,0));
    string verilogdirectory="/verilogGeneratedRTL/";
    location+=verilogdirectory;
    stringstream outfilename;
    string filename="Mix_Add_Mult_RTL";
    int fileint=x;
    outfilename << filename << fileint << "Bits.v";
    string f=outfilename.str();
    string finaloutputfilename;
    finaloutputfilename=location+f;
    //cout<<finaloutputfilename;
    ofstream outfile(finaloutputfilename);
    outfile<<"/*This Verilog is generated by BechGen software.*/\n"
          "/*Designed by University of Massachusetts, Amherst, VLSI CAD LAB, Cunxi Yu*/\n"
          "/*/  Copyright (c) 2014 Cunxi Yu. All rights reserved. */ \n"
          "/*Contact: ycunxi@umass.edu */"<<endl;
    outfile<<"module BenchmarkRTL(a,b,c,z);"<<endl;
    outfile<<" input ["<<x-1<<":0] a,b,c;"<<endl;
    outfile<<" output ["<<2*x<<":0] z;"<<endl;
    outfile<<" wire ["<<2*x<<":0] z;"<<endl;
    outfile<<"    assign z=a*b+a*c;"<<endl;
    outfile<<"endmodule"<<endl;
}
void BenchGen::gatelevelbenchADD(int x)
//The gate level Verilog HDL code for circuit-(a+b)
{
    x--;
    string location(getcwd(NULL,0));
    string verilogdirectory="/verilogGenerated/";
    location+=verilogdirectory;
    stringstream outfilename;
    string filename="Adder";
    int fileint=x+1;
    outfilename << filename << fileint << "Bits.v";
    string f=outfilename.str();
    string finaloutputfilename;
    finaloutputfilename=location+f;
    //cout<<finaloutputfilename;
    ofstream outfile(finaloutputfilename);
    outfile<<"/*This Verilog is generated by BechGen software.*/\n"
          "/*Designed by University of Massachusetts, Amherst, VLSI CAD LAB, Cunxi Yu*/\n"
          "/*/  Copyright (c) 2014 Cunxi Yu. All rights reserved. */ \n"
          "/*Contact: ycunxi@umass.edu */"<<endl;

    outfile<<"module adder"<<x+1<<"Bits(a,b,z);"<<endl;
    outfile<<" input ["<<x<<":0] a;"<<endl;
    outfile<<" input ["<<x<<":0] b;"<<endl;
    outfile<<" output ["<<x+1<<":0] z;"<<endl;
    outfile<<" wire ["<<x-1<<":0] adder_add_cout;"<<endl;
    outfile<<"    assign adder_and0 = a[0] & b[0] ;"<<endl;
    outfile<<"    assign adder_add_cout[0] = adder_and0;"<<endl;
    outfile<<"    assign z[0] = a[0] ^ b[0];"<<endl;
    for (int i=1; i<=x; i++) {
        if (i!=x) {
            outfile<<"    assign adder_and"<<3*i-2<<" = adder_add_cout["<<i-1<<"] & a["<<i<<"];"<<endl;
            outfile<<"    assign adder_and"<<3*i-1<<" = adder_add_cout["<<i-1<<"] & b["<<i<<"];"<<endl;
            outfile<<"    assign adder_and"<<3*i<<" = a["<<i<<"] & b["<<i<<"];"<<endl;
            outfile<<"    assign adder_or"<<i<<" = adder_and"<<3*i-2<<" | "<<"adder_and"<<3*i-1<<";"<<endl;
            outfile<<"    assign adder_add_cout["<<i<<"] = adder_or"<<i<<" | ""adder_and"<<3*i<<";"<<endl;
            
            outfile<<"    assign adder_xor"<<i<<" = a["<<i<<"] ^ b["<<i<<"];"<<endl;
            outfile<<"    assign z["<<i<<"] = adder_xor"<<i<<" ^ "<<"adder_add_cout["<<i-1<<"];"<<endl;
        }
        else
        {
            outfile<<"    assign adder_and"<<3*i-2<<" = adder_add_cout["<<i-1<<"] & a["<<i<<"];"<<endl;
            outfile<<"    assign adder_and"<<3*i-1<<" = adder_add_cout["<<i-1<<"] & b["<<i<<"];"<<endl;
            outfile<<"    assign adder_and"<<3*i<<" = a["<<i<<"] & b["<<i<<"];"<<endl;
            outfile<<"    assign adder_or"<<i<<" = adder_and"<<3*i-2<<" | "<<"adder_and"<<3*i-1<<";"<<endl;
            outfile<<"    assign z["<<i+1<<"] = adder_or"<<i<<" | adder_and"<<3*i<<";"<<endl;
            outfile<<"    assign adder_xor"<<i<<" = a["<<i<<"] ^ b["<<i<<"];"<<endl;
            outfile<<"    assign z["<<i<<"] = adder_xor"<<i<<" ^ "<<"adder_add_cout["<<i-1<<"];"<<endl;
        }
    }
    outfile<<"endmodule"<<endl;
}

//The gatelevelbenchADD(int x) is same is this. Cause XCODE has a little error when compliering.
/*
void BenchGen::gatelevelAdder(int x)
{
    x--;
    verilogFile();
    outfile<<"module adder"<<x+1<<"Bits(a,b,adder_add_sum);"<<endl;
    outfile<<" input ["<<x<<":0] a,b;"<<endl;
    outfile<<" output ["<<x+1<<":0] adder_add_sum;"<<endl;
    outfile<<" wire ["<<x+1<<":0] adder_add_sum;"<<endl;
    outfile<<" wire ["<<x-1<<":0] adder_add_cout;"<<endl;
    outfile<<"    assign adder_and0 = a[0] & b[0];"<<endl;
    outfile<<"    assign adder_add_cout[0] = adder_and0;"<<endl;
    outfile<<"    assign adder_add_sum[0] = a[0] ^ b[0];"<<endl;
    for (int i=1; i<=x; i++) {
        if (i!=x) {
            outfile<<"    assign adder_and"<<3*i-2<<" = adder_add_cout["<<i-1<<"] & a["<<i<<"];"<<endl;
            outfile<<"    assign adder_and"<<3*i-1<<" = adder_add_cout["<<i-1<<"] & b["<<i<<"];"<<endl;
            outfile<<"    assign adder_and"<<3*i<<" = a["<<i<<"] & b["<<i<<"];"<<endl;
            outfile<<"    assign adder_or"<<i<<" = adder_and"<<3*i-2<<" | "<<"adder_and"<<3*i-1<<";"<<endl;
            outfile<<"    assign adder_add_cout["<<i<<"] = adder_or"<<i<<" | ""adder_and"<<3*i<<";"<<endl;

            outfile<<"    assign adder_xor"<<i<<" = a["<<i<<"] ^ b["<<i<<"];"<<endl;
            outfile<<"    assign adder_add_sum["<<i<<"] = adder_xor"<<i<<" ^ "<<"adder_add_cout["<<i-1<<"];"<<endl;
                    }
        else
        {
            outfile<<"    assign adder_and"<<3*i-2<<" = adder_add_cout["<<i-1<<"] & a["<<i<<"];"<<endl;
            outfile<<"    assign adder_and"<<3*i-1<<" = adder_add_cout["<<i-1<<"] & b["<<i<<"];"<<endl;
            outfile<<"    assign adder_and"<<3*i<<" = a["<<i<<"] & b["<<i<<"];"<<endl;
            outfile<<"    assign adder_or"<<i<<" = adder_and"<<3*i-2<<" | "<<"adder_and"<<3*i-1<<";"<<endl;
            outfile<<"    assign adder_add_sum["<<i+1<<"] = adder_or"<<i<<" | adder_and"<<3*i<<";"<<endl;
            outfile<<"    assign adder_xor"<<i<<" = a["<<i<<"] ^ b["<<i<<"];"<<endl;
            outfile<<"    assign adder_add_sum["<<i<<"] = adder_xor"<<i<<" ^ "<<"adder_add_cout["<<i-1<<"];"<<endl;
        }
    }
    outfile<<"endmodule";
} */

void BenchGen::arbitraryRTLAdder(int x)
{
    
    x--;
    string location(getcwd(NULL,0));
    string verilogdirectory="/verilogGeneratedRTL/";
    location+=verilogdirectory;
    stringstream outfilename;
    string filename="Adder_RTL";
    int fileint=x+1;
    outfilename << filename << fileint << "Bits.v";
    string f=outfilename.str();
    string finaloutputfilename;
    finaloutputfilename=location+f;
    //cout<<finaloutputfilename;
    ofstream outfile(finaloutputfilename);
    outfile<<"/*This Verilog is generated by BechGen software.*/\n"
          "/*Designed by University of Massachusetts, Amherst, VLSI CAD LAB, Cunxi Yu*/\n"
          "/*/  Copyright (c) 2014 Cunxi Yu. All rights reserved. */ \n"
          "/*Contact: ycunxi@umass.edu */"<<endl;
    outfile<<"module AdderRTL(a,b,z);"<<endl;
    outfile<<"  input ["<<x<<":0] a,b;"<<endl;
    outfile<<"  output ["<<x+1<<":0] z;"<<endl;
    outfile<<"  wire ["<<x+1<<":0] z;"<<endl;
    outfile<<"         assign z=a+b;"<<endl;
    outfile<<"endmodule"<<endl;
}

void multiplierCSAstage1(int x,int y)
//N+1 bits * N bits
{
    x--;
    y--;
    string location(getcwd(NULL,0));
    string verilogdirectory="/verilogGenerated/";
    location+=verilogdirectory;
    stringstream outfilename;
    string filename="Multiplier";
    int fileint=x+1;
    outfilename << filename << fileint << "Bits.v";
    string f=outfilename.str();
    string finaloutputfilename;
    finaloutputfilename=location+f;
    //cout<<finaloutputfilename;
    ofstream outfile(finaloutputfilename,ios::app);
    outfile<<"module CSAMultiplier(a,b,z);"<<endl;
    outfile<<" input ["<<x<<":0] a;"<<endl;
    outfile<<" input ["<<y<<":0] b;"<<endl;
    outfile<<" output ["<<x+y+1<<":0] z;"<<endl;
    outfile<<" wire ["<<x+y+1<<":0] z;"<<endl;
    int n=0;
    for (int i=0; i<=x; i++) {
        outfile<<"    assign mult_stage1"<<"_and"<<n<<" = a["<<i<<"] & b[0];"<<endl;
        n++;
        if(i!=x)
        {
        outfile<<"    assign mult_stage1"<<"_and"<<n<<" = a["<<i<<"] & b[1];"<<endl;
        }
        n++;
    }
    outfile<<"    assign z[0] = a[0] & b[0];"<<endl;
    // outfile<<"    assign mult_stage1_cout0 = mult_stage1_and0;"<<endl;
    for (int i_add=1; i_add<=x; i_add++) {
        if (i_add!=1) {
            outfile<<"    assign mult_stage1_sum"<<i_add-1<<" = mult_stage1_and"<<2*i_add-1<<" ^ mult_stage1_and"<<2*i_add<<";"<<endl;
            outfile<<"    assign mult_stage1_cout"<<i_add-1<<" = mult_stage1_and"<<2*i_add-1<<" & mult_stage1_and"<<2*i_add<<";"<<endl;
            
        }
        else
        {
            outfile<<"    assign z[1] = mult_stage1_and1 ^ mult_stage1_and2;"<<endl;
            outfile<<"    assign mult_stage1_cout"<<i_add-1<<" = mult_stage1_and"<<i_add<<" & mult_stage1_and"<<i_add+1<<";"<<endl;
        }
    }
    outfile<<" /* This is the CSA multiplier first Stage.*/"<<endl;
}
//After first stage

void multiplierCSAstage2(int x_1,int x_2)
{
    string location(getcwd(NULL,0));
    string verilogdirectory="/verilogGenerated/";
    location+=verilogdirectory;
    stringstream outfilename;
    string filename="Multiplier";
    int fileint=x_1;
    outfilename << filename << fileint << "Bits.v";
    string f=outfilename.str();
    string finaloutputfilename;
    finaloutputfilename=location+f;
    //cout<<finaloutputfilename;
    ofstream outfile(finaloutputfilename,ios::app);
    for (int stage2=2; stage2<=x_2-1; stage2++) {
        for (int fulladder=0; fulladder<=x_1-2; fulladder++) {
            
            if (fulladder==x_1-2) {
                // outfile<<"    assign mult_stage"<<stage2<<"_cout"<<fulladder<<" = ( a["<<fulladder<<"] & b["<<stage2<<"] & mult_stage"<<stage2-1<<"_cout"<<fulladder<<" ) | (a["<<fulladder+1<<"] & b["<<stage2-1<<"]"<<" & a["<<fulladder<<"] & b["<<stage2<<"]) | (mult_stage"<<stage2-1<<"_cout"<<fulladder<<" & a["<<fulladder+1<<"] & b["<<stage2-1<<"]"<<");"<<endl;
                outfile<<"    assign mult_stage"<<stage2<<"_and"<<5*(fulladder+1)-4<<" = a["<<fulladder<<"] & b["<<stage2<<"];"<<endl;
                outfile<<"    assign mult_stage"<<stage2<<"_and"<<5*(fulladder+1)-3<<" = a["<<fulladder+1<<"] & b["<<stage2-1<<"];"<<endl;
                outfile<<"    assign mult_stage"<<stage2<<"_and"<<5*(fulladder+1)-2<<" = mult_stage"<<stage2<<"_and"<<5*(fulladder+1)-4<<" & mult_stage"<<stage2-1<<"_cout"<<fulladder<<";"<<endl;
                outfile<<"    assign mult_stage"<<stage2<<"_and"<<5*(fulladder+1)-1<<" = mult_stage"<<stage2<<"_and"<<5*(fulladder+1)-3<<" & mult_stage"<<stage2-1<<"_cout"<<fulladder<<";"<<endl;
                outfile<<"    assign mult_stage"<<stage2<<"_and"<<5*(fulladder+1)<<" = mult_stage"<<stage2<<"_and"<<5*(fulladder+1)-4<<" & mult_stage"<<stage2<<"_and"<<5*(fulladder+1)-3<<";"<<endl;
                outfile<<"    assign mult_stage"<<stage2<<"_or"<<fulladder<<" = mult_stage"<<stage2<<"_and"<<5*(fulladder+1)-2<<" | mult_stage"<<stage2<<"_and"<<5*(fulladder+1)-1<<";"<<endl;
                outfile<<"    assign mult_stage"<<stage2<<"_cout"<<fulladder<<" = mult_stage"<<stage2<<"_or"<<fulladder<<" | mult_stage"<<stage2<<"_and"<<5*(fulladder+1)<<";"<<endl;
                
                
                //outfile<<"    assign mult_stage"<<stage2<<"_sum"<<fulladder<<" = ( a["<<fulladder<<"] & b["<<stage2<<"] ) ^ (a["<<fulladder+1<<"] & b["<<stage2-1<<"])"<<" ^ mult_stage"<<stage2-1<<"_cout"<<fulladder<<";"<<endl;
                outfile<<"    assign mult_stage"<<stage2<<"_xor"<<fulladder<<" = mult_stage"<<stage2<<"_and"<<5*(fulladder+1)-4<<" ^ mult_stage"<<stage2<<"_and"<<5*(fulladder+1)-3<<";"<<endl;
                outfile<<"    assign mult_stage"<<stage2<<"_sum"<<fulladder<<" = mult_stage"<<stage2<<"_xor"<<fulladder<<" ^ mult_stage"<<stage2-1<<"_cout"<<fulladder<<";"<<endl;
            }
            else if(fulladder==0)
            {
                //outfile<<"    assign mult_stage"<<stage2<<"_cout"<<fulladder<<" = ( a["<<fulladder<<"] & b["<<stage2<<"] & mult_stage"<<stage2-1<<"_cout"<<fulladder<<" ) | (mult_stage"<<stage2-1<<"_sum"<<fulladder+1<<" & a["<<fulladder<<"] & b["<<stage2<<"]) | (mult_stage"<<stage2-1<<"_cout"<<fulladder<<" & mult_stage"<<stage2-1<<"_sum"<<fulladder+1<<");"<<endl;
                outfile<<"    assign mult_stage"<<stage2<<"_and"<<4*(fulladder+1)-3<<" = a["<<fulladder<<"] & b["<<stage2<<"];"<<endl;
                outfile<<"    assign mult_stage"<<stage2<<"_and"<<4*(fulladder+1)-2<<" = mult_stage"<<stage2<<"_and"<<4*(fulladder+1)-3<<" & mult_stage"<<stage2-1<<"_cout"<<fulladder<<";"<<endl;
                outfile<<"    assign mult_stage"<<stage2<<"_and"<<4*(fulladder+1)-1<<" = mult_stage"<<stage2<<"_and"<<4*(fulladder+1)-3<<" & mult_stage"<<stage2-1<<"_sum"<<fulladder+1<<";"<<endl;
                outfile<<"    assign mult_stage"<<stage2<<"_and"<<4*(fulladder+1)<<" = mult_stage"<<stage2-1<<"_cout"<<fulladder<<" & mult_stage"<<stage2-1<<"_sum"<<fulladder+1<<";"<<endl;
                outfile<<"    assign mult_stage"<<stage2<<"_or"<<fulladder<<" = mult_stage"<<stage2<<"_and"<<4*(fulladder+1)-2<<" | mult_stage"<<stage2<<"_and"<<4*(fulladder+1)-1<<";"<<endl;
                outfile<<"    assign mult_stage"<<stage2<<"_cout"<<fulladder<<" = mult_stage"<<stage2<<"_or"<<fulladder<<" | mult_stage"<<stage2<<"_and"<<4*(fulladder+1)<<";"<<endl;
                
                //outfile<<"    assign z["<<stage2<<"] = ( a["<<fulladder<<"] & b["<<stage2<<"] ) ^ mult_stage"<<stage2-1<<"_sum"<<fulladder+1<<" ^ mult_stage"<<stage2-1<<"_cout"<<fulladder<<";"<<endl;
                outfile<<"    assign mult_stage"<<stage2<<"_xor"<<fulladder<<" = mult_stage"<<stage2<<"_and"<<4*(fulladder+1)-3<<" ^ mult_stage"<<stage2-1<<"_cout"<<fulladder<<";"<<endl;
                outfile<<"    assign z["<<stage2<<"] = mult_stage"<<stage2<<"_xor"<<fulladder<<" ^ mult_stage"<<stage2-1<<"_sum"<<fulladder+1<<";"<<endl;
                
            }
            
            else
            {
                //outfile<<"    assign mult_stage"<<stage2<<"_cout"<<fulladder<<" = ( a["<<fulladder<<"] & b["<<stage2<<"] & mult_stage"<<stage2-1<<"_cout"<<fulladder<<" ) | (mult_stage"<<stage2-1<<"_sum"<<fulladder+1<<" & (a["<<fulladder<<"] & b["<<stage2<<"]) ) | (mult_stage"<<stage2-1<<"_cout"<<fulladder<<" & mult_stage"<<stage2-1<<"_sum"<<fulladder+1<<");"<<endl;
                outfile<<"    assign mult_stage"<<stage2<<"_and"<<4*(fulladder+1)-3<<" = a["<<fulladder<<"] & b["<<stage2<<"];"<<endl;
                outfile<<"    assign mult_stage"<<stage2<<"_and"<<4*(fulladder+1)-2<<" = mult_stage"<<stage2<<"_and"<<4*(fulladder+1)-3<<" & mult_stage"<<stage2-1<<"_cout"<<fulladder<<";"<<endl;
                outfile<<"    assign mult_stage"<<stage2<<"_and"<<4*(fulladder+1)-1<<" = mult_stage"<<stage2<<"_and"<<4*(fulladder+1)-3<<" & mult_stage"<<stage2-1<<"_sum"<<fulladder+1<<";"<<endl;
                outfile<<"    assign mult_stage"<<stage2<<"_and"<<4*(fulladder+1)<<" = mult_stage"<<stage2-1<<"_cout"<<fulladder<<" & mult_stage"<<stage2-1<<"_sum"<<fulladder+1<<";"<<endl;
                outfile<<"    assign mult_stage"<<stage2<<"_or"<<fulladder<<" = mult_stage"<<stage2<<"_and"<<4*(fulladder+1)-2<<" | mult_stage"<<stage2<<"_and"<<4*(fulladder+1)-1<<";"<<endl;
                outfile<<"    assign mult_stage"<<stage2<<"_cout"<<fulladder<<" = mult_stage"<<stage2<<"_or"<<fulladder<<" | mult_stage"<<stage2<<"_and"<<4*(fulladder+1)<<";"<<endl;
                
                //outfile<<"    assign mult_stage"<<stage2<<"_sum"<<fulladder<<" = ( a["<<fulladder<<"] & b["<<stage2<<"] ) ^ mult_stage"<<stage2-1<<"_sum"<<fulladder+1<<" ^ mult_stage"<<stage2-1<<"_cout"<<fulladder<<";"<<endl;
                outfile<<"    assign mult_stage"<<stage2<<"_xor"<<fulladder<<" = mult_stage"<<stage2<<"_and"<<4*(fulladder+1)-3<<" ^ mult_stage"<<stage2-1<<"_sum"<<fulladder+1<<";"<<endl;
                outfile<<"    assign mult_stage"<<stage2<<"_sum"<<fulladder<<" = mult_stage"<<stage2<<"_xor"<<fulladder<<" ^ mult_stage"<<stage2-1<<"_cout"<<fulladder<<";"<<endl;
                
            }
            
        }
    }
    
}

//Last stage of CSA Multiplier
void multiplierCSAlastStage(int x_1,int x_2)
{
    string location(getcwd(NULL,0));
    string verilogdirectory="/verilogGenerated/";
    location+=verilogdirectory;
    stringstream outfilename;
    string filename="Multiplier";
    int fileint=x_1;
    outfilename << filename << fileint << "Bits.v";
    string f=outfilename.str();
    string finaloutputfilename;
    finaloutputfilename=location+f;
    //cout<<finaloutputfilename;
    ofstream outfile(finaloutputfilename,ios::app);
    outfile<<"/*This is the LAST stage for CSA multiplier.*/"<<endl;
    for (int fulladder=0; fulladder<=x_1-1; fulladder++) {
        if(fulladder==0)
        {
            outfile<<"    assign mult_laststage_cout"<<fulladder<<" = mult_stage"<<x_2-1<<"_sum"<<fulladder+1<<" & mult_stage"<<x_2-1<<"_cout"<<fulladder<<";"<<endl;
            outfile<<"    assign z["<<x_2+fulladder<<"] = mult_stage"<<x_2-1<<"_sum"<<fulladder+1<<" ^ mult_stage"<<x_2-1<<"_cout"<<fulladder<<";"<<endl;
        }
        else if (fulladder==x_1-1)
        {
            //outfile<<"    assign mult_laststage_cout"<<fulladder<<" = (a["<<x_1-1<<"] & b["<<x_2-1<<"]"<<" & mult_stage"<<x_2-1<<"_cout"<<fulladder<<") | (a["<<x_1-1<<"] & b["<<x_1-1<<"] & mult_laststage_cout"<<fulladder-1<<") | (mult_stage"<<x_2-1<<"_cout"<<fulladder<<" & mult_laststage_cout"<<fulladder-1<<");"<<endl;
            outfile<<"    assign z["<<x_2+x_1-1<<"] = mult_laststage_cout"<<fulladder-1<<";"<<endl;
        }
        else if(fulladder==x_1-2)
        {
            //outfile<<"    assign mult_laststage_cout"<<fulladder<<" = ( a["<<x_1-1<<"] & b["<<x_2-1<<"] & mult_stage"<<x_2-1<<"_cout"<<fulladder<<") | ( a["<<x_1-1<<"] & b["<<x_2-1<<"] & mult_laststage"<<"_cout"<<fulladder-1<<") | (mult_stage"<<x_2-1<<"_cout"<<fulladder<<" & mult_laststage"<<"_cout"<<fulladder-1<<");"<<endl;
            outfile<<"    assign mult_laststage_and"<<4*fulladder-3<<" = a["<<x_1-1<<"] & b["<<x_2-1<<"];"<<endl;
            outfile<<"    assign mult_laststage_and"<<4*fulladder-2<<" = mult_laststage_and"<<4*fulladder-3<<" & mult_stage"<<x_2-1<<"_cout"<<fulladder<<";"<<endl;
            outfile<<"    assign mult_laststage_and"<<4*fulladder-1<<" = mult_laststage_and"<<4*fulladder-3<<" & mult_laststage"<<"_cout"<<fulladder-1<<";"<<endl;
            outfile<<"    assign mult_laststage_and"<<4*fulladder<<" = mult_stage"<<x_2-1<<"_cout"<<fulladder<<" & mult_laststage"<<"_cout"<<fulladder-1<<";"<<endl;
            outfile<<"    assign mult_laststage_or"<<fulladder<<" = mult_laststage_and"<<4*fulladder-2<<" | mult_laststage_and"<<4*fulladder-1<<";"<<endl;
            outfile<<"    assign mult_laststage_cout"<<fulladder<<" = mult_laststage_or"<<fulladder<<" | mult_laststage_and"<<4*fulladder<<";"<<endl;
            //outfile<<"    assign z["<<x_2+fulladder<<"] = mult_laststage_cout"<<fulladder-1<<" ^ ( a["<<x_1-1<<"] & b["<<x_2-1<<"] ) ^ mult_stage"<<x_2-1<<"_cout"<<fulladder<<";"<<endl;
            outfile<<"    assign mult_laststage_xor"<<fulladder<<" = mult_laststage_cout"<<fulladder-1<<" ^ mult_laststage_and"<<4*fulladder-3<<";"<<endl;
            outfile<<"    assign z["<<x_2+fulladder<<"] = mult_laststage_xor"<<fulladder<<" ^ mult_stage"<<x_2-1<<"_cout"<<fulladder<<";"<<endl;
        }
        else
        {
            
            
            //outfile<<"    assign mult_laststage_cout"<<fulladder<<" = (mult_stage"<<x_2-1<<"_sum"<<fulladder+1<<" & mult_stage"<<x_2-1<<"_cout"<<fulladder<<") | (mult_stage"<<x_2-1<<"_sum"<<fulladder+1<<" & mult_laststage"<<"_cout"<<fulladder-1<<") | (mult_stage"<<x_2-1<<"_cout"<<fulladder<<" & mult_laststage"<<"_cout"<<fulladder-1<<");"<<endl;
            outfile<<"    assign mult_laststage_and"<<4*fulladder-3<<" = mult_stage"<<x_2-1<<"_sum"<<fulladder+1<<" & mult_stage"<<x_2-1<<"_cout"<<fulladder<<";"<<endl;
            outfile<<"    assign mult_laststage_and"<<4*fulladder-2<<" = mult_stage"<<x_2-1<<"_sum"<<fulladder+1<<" & mult_laststage"<<"_cout"<<fulladder-1<<";"<<endl;
            outfile<<"    assign mult_laststage_and"<<4*fulladder-1<<" = mult_stage"<<x_2-1<<"_cout"<<fulladder<<" & mult_laststage"<<"_cout"<<fulladder-1<<";"<<endl;
            outfile<<"    assign mult_laststage_or"<<fulladder<<" = mult_laststage_and"<<4*fulladder-3<<" | mult_laststage_and"<<4*fulladder-2<<";"<<endl;
            outfile<<"    assign mult_laststage_cout"<<fulladder<<" = mult_laststage_or"<<fulladder<<" | mult_laststage_and"<<4*fulladder-1<<";"<<endl;
            //outfile<<"    assign z["<<x_2+fulladder<<"] = mult_laststage_cout"<<fulladder-1<<" ^ mult_stage"<<x_2-1<<"_sum"<<fulladder+1<<" ^ mult_stage"<<x_2-1<<"_cout"<<fulladder<<";"<<endl;
            outfile<<"    assign mult_laststage_xor"<<fulladder<<" = mult_laststage_cout"<<fulladder-1<<" ^ mult_stage"<<x_2-1<<"_sum"<<fulladder+1<<";"<<endl;
            outfile<<"    assign z["<<x_2+fulladder<<"] = mult_laststage_xor"<<fulladder<<" ^ mult_stage"<<x_2-1<<"_cout"<<fulladder<<";"<<endl;
            
            
        }
    }
    outfile<<"endmodule"<<endl;
    outfile<<"/* This is verilog file of multiplier designed by BechGen software.*/"<<endl;
}

void BenchGen::EntierMultiplierGen(int bit1,int bit2)
{
    string location(getcwd(NULL,0));
    string verilogdirectory="/verilogGenerated/";
    location+=verilogdirectory;
    stringstream outfilename;
    string filename="Multiplier";
    int fileint=bit1;
    outfilename << filename << fileint << "Bits.v";
    string f=outfilename.str();
    string finaloutputfilename;
    finaloutputfilename=location+f;
    //cout<<finaloutputfilename;
    ofstream outfile(finaloutputfilename);
    outfile<<"/*This Verilog is generated by BechGen software.*/\n"
          "/*Designed by University of Massachusetts, Amherst, VLSI CAD LAB, Cunxi Yu*/\n"
          "/*/  Copyright (c) 2014 Cunxi Yu. All rights reserved. */ \n"
          "/*Contact: ycunxi@umass.edu */"<<endl;
    multiplierCSAstage1(bit1, bit2);
    multiplierCSAstage2(bit1, bit2);
    multiplierCSAlastStage(bit1,bit2);
}

void BenchGen::MultiplierRTL(int x)
{
    x--;
    string location(getcwd(NULL,0));
    string verilogdirectory="/verilogGeneratedRTL/";
    location+=verilogdirectory;
    stringstream outfilename;
    string filename="Multiplier_RTL";
    int fileint=x+1;
    outfilename << filename << fileint << "Bits.v";
    string f=outfilename.str();
    string finaloutputfilename;
    finaloutputfilename=location+f;
    //cout<<finaloutputfilename;
    ofstream outfile(finaloutputfilename);
    outfile<<"/*This Verilog is generated by BechGen software.*/\n"
          "/*Designed by University of Massachusetts, Amherst, VLSI CAD LAB, Cunxi Yu*/\n"
          "/*/  Copyright (c) 2014 Cunxi Yu. All rights reserved. */ \n"
          "/*Contact: ycunxi@umass.edu */"<<endl;
    outfile<<"module MultiplierRTL(a,b,z);"<<endl;
    outfile<<"  input ["<<x<<":0] a,b;"<<endl;
    outfile<<"  output ["<<2*x+1<<":0] z;"<<endl;
    outfile<<"  wire ["<<2*x+1<<":0] z;"<<endl;
    outfile<<"  assign z=a*b;"<<endl;
    outfile<<"endmodule"<<endl;
    
}



